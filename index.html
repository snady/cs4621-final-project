<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621: FINAL</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="container">

    <div align="center">
        <canvas tabindex="1" id="webglCanvas" style="position: absolute;left: 0; top: 0;border: none; background-color: black; width: 100vw;height: 100vh;" ></canvas>
    </div>

    <br>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="js/gl-matrix-min.js"></script>
<script src="js/preloadjs-0.6.2.min.js"></script>
<script src="js/terrain.js"></script>
<script src="js/particle.js"></script>
<script src="scenes.js"></script>




<!-- Shaders -->

<!-- vertex shader -->
<script id="vertexShaderTRN" type="x-shader/x-vertex">

    attribute vec3 position;
    attribute vec2 texture_coords;
    attribute float a_biome;

    /*uniform vec3 cameraPos;
    uniform float heading;
    uniform float phi;
    */

    uniform mat4 mProj;
    uniform mat4 mCam;

    varying vec2 tcoords;
    varying float biome;

    varying vec3 worldCoords;

    void main() {
        /*
        vec3 e = cameraPos;
        //vec3 w = normalize(vec3(cos(heading), cos(phi), -sin(heading)) * -1.0);
        vec3 w = normalize(vec3(sin(phi)*cos(heading), cos(phi), sin(phi)*-sin(heading)) * -1.0);
        //vec3 w = vec3(0.0, 0.0, 1.0);
<<<<<<< HEAD
        vec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));
        vec3 v = normalize(cross(w, u));
=======
		vec3 up = normalize(vec3(-cos(heading)*cos(phi), sin(phi), sin(heading)*cos(phi)));
        vec3 u = cross(up, w);
        vec3 v = cross(w, u);
>>>>>>> f95d9e70c73aec2c4f98fc9f1ebad397194866f3

        mat4 A = mat4(
                u.x, v.x, w.x, 0.0,
                u.y, v.y, w.y, 0.0,
                u.z, v.z, w.z, 0.0,
                0.0, 0.0, 0.0, 1.0);
        mat4 B = mat4(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            -e.x, -e.y, -e.z, 1.0);
        mat4 mCam = A*B;

        // if (position.y > 6.0) {
        //     biome = 3.0;
        // } else if (position.y > 3.0) {
        //     biome = 2.0;
        // } else {
        //     biome = 1.0;
        // }
        */

       biome = a_biome;

       tcoords = texture_coords;
       gl_Position = mProj*mCam*vec4(position, 1.0);

       worldCoords = position;
    }

</script>

<script id="fragmentTRN" type="x-shader/x-fragment">
    precision highp float;

    #define GRASS 2.0
    #define DIRT 3.0
    #define DESERT 1.0
    #define STONE 4.0
    #define WATER 0.0

    uniform sampler2D grass;
    uniform sampler2D dirt;
    uniform sampler2D desert;
    uniform sampler2D stone;
    uniform sampler2D water;
    varying vec2 tcoords;
    varying float biome;

    uniform float time;
    uniform sampler2D waterNormals;
    uniform vec3 cameraPos;
    varying vec3 worldCoords;

    vec4 getNoise(vec2 uv){
        vec2 uv0 = (uv/103.0)+vec2(time/17.0, time/29.0);
        vec2 uv1 = uv/107.0-vec2(time/-19.0, time/31.0);
        vec2 uv2 = uv/vec2(897.0, 983.0)+vec2(time/101.0, time/97.0);
        vec2 uv3 = uv/vec2(991.0, 877.0)-vec2(time/109.0, time/-113.0);
        vec4 noise = (texture2D(waterNormals, uv0)) +
                     (texture2D(waterNormals, uv1)) +
                     (texture2D(waterNormals, uv2)) +
                     (texture2D(waterNormals, uv3));
        return noise*0.5-1.0;
    }

    void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse,
                  inout vec3 diffuseColor, inout vec3 specularColor){
        vec3 sunDirection = normalize(vec3(0.5, 0.25, 0.5));
        vec3 sunColor = vec3(15.3,15.75,25.65);
        vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));
        float direction = max(0.0, dot(eyeDirection, reflection));
        specularColor += pow(direction, shiny)*sunColor*spec;
        diffuseColor += max(dot(sunDirection, surfaceNormal),0.0)*sunColor*diffuse;
    }

    // Main
    void main() {
        if (biome >= STONE) {
            gl_FragColor = texture2D(stone, tcoords);
        } else if (biome >= DIRT) {
            gl_FragColor = (1.0 - (biome-DIRT)) * texture2D(dirt, tcoords) + (biome-DIRT) * texture2D(stone, tcoords);
        } else if (biome >= GRASS) {
            gl_FragColor = (1.0 - (biome-GRASS)) * texture2D(grass, tcoords) + (biome-GRASS) * texture2D(dirt, tcoords);
        } else if (biome >= DESERT) {
            gl_FragColor = (1.0 - (biome-DESERT)) * texture2D(desert, tcoords) + (biome-DESERT) * texture2D(grass, tcoords);
        } else {
            gl_FragColor = (1.0 - biome) * texture2D(desert, tcoords) + biome * texture2D(desert, tcoords);
            /*vec4 noise = getNoise(worldCoords.xz);
            vec3 surfaceNormal = normalize(noise.xzy*vec3(2.0, 1.0, 2.0));

            vec3 diffuse = vec3(0.0);
            vec3 specular = vec3(0.0);

            vec3 worldToEye = cameraPos-worldCoords;
            vec3 eyeDirection = normalize(worldToEye);
            sunLight(surfaceNormal, eyeDirection, 35.0, 2.0, 0.5, diffuse, specular);

            gl_FragColor = vec4((diffuse+specular+vec3(0.1))*vec3(0.3, 0.5, 0.9), 1.0);*/
        }
    }

</script>

<script id="waterVertex" type="x-shader/x-vertex">
    attribute vec3 position;

    uniform mat4 mProj;
    uniform mat4 mCam;

    varying vec4 clipCoords;
    varying vec2 texCoords;

    void main() {
        clipCoords = mProj*mCam*vec4(position, 1.0);
        gl_Position = clipCoords;
        texCoords = vec2(position.x/2.0, position.z/2.0);
    }
</script>

<script id="waterFragment" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D refraction;
    uniform sampler2D dudvMap;

    varying vec4 clipCoords;
    varying vec2 texCoords;

    void main() {
        vec2 ndc = ((clipCoords.xy/clipCoords.w)/2.0) + 0.5;

        vec2 refractTexCoords = vec2(ndc.x, ndc.y);

        vec2 distortion = 0.3 * ((texture2D(dudvMap, texCoords).rg * 2.0) - 1.0);

        refractTexCoords = refractTexCoords + distortion;
        vec4 refraction = texture2D(refraction, refractTexCoords);

        gl_FragColor = mix(refraction, vec4(0.529, 0.808, 0.98, 1.0), 0.5);
    }

</script>

<script id="vertexSNOW" type="x-shader/x-vertex">
	attribute vec3 position;
	attribute vec2 texture_coords;

    uniform vec3 cameraPos;
    uniform float heading;
    uniform float phi;
    uniform mat4 mProj;

    varying vec2 tcoords;

	void main() {
        vec3 e = cameraPos;
        vec3 w = normalize(vec3(cos(heading), cos(phi), -sin(heading)) * -1.0);
        vec3 up = normalize(vec3(-cos(heading)*cos(phi), sin(phi), sin(heading)*cos(phi)));
        vec3 u = cross(up, w);
        vec3 v = cross(w, u);

        mat4 A = mat4(
                u.x, v.x, w.x, 0.0,
                u.y, v.y, w.y, 0.0,
                u.z, v.z, w.z, 0.0,
                0.0, 0.0, 0.0, 1.0);
        mat4 B = mat4(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            -e.x, -e.y, -e.z, 1.0);
        mat4 mCam = A*B;

        //spherical billboarding
        mCam[0][0] = 1.0;
        mCam[0][1] = 0.0;
        mCam[0][2] = 0.0;

     	mCam[1][0] = 0.0;
	    mCam[1][1] = 1.0;
	    mCam[1][2] = 0.0;

	 	mCam[2][0] = 0.0;
	  	mCam[2][1] = 0.0;
	  	mCam[2][2] = 1.0;

	  	tcoords = texture_coords;
		gl_Position = mProj*mCam*vec4(position, 1.0);
	}

</script>

<script id="fragmentSNOW" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D snow;
    varying vec2 tcoords;

    void main(){
    	gl_FragColor = texture2D(snow, tcoords);
    }

</script>


<script>

    $("#webglCanvas").click(function (event) {
        //console.log("clicked");
    });

    $("#webglCanvas").keydown(function (event) {
        var deltav = 0.5;
        var acc = 0.1;
        switch(event.key){
            case "w":
                acceleration[0] = -1.0*acc;
                break;
            case "s":
                acceleration[0] = acc;
                break;
            case "a":
                acceleration[1] = -1.0*acc;
                break;
            case "d":
                acceleration[1] = acc;
                break;
            case "Shift":
                acceleration[2] = -1.0*acc;
                break;
            case " ":
                acceleration[2] = acc;
                break;
            case "ArrowUp":
                if(phi > 20.0/180*Math.PI){dphi = -0.05;}else{dphi = 0.0}
                break;
            case "ArrowDown":
                if(phi < Math.PI*160/180){dphi = 0.05;}else{dphi = 0.0}
                break;
            case "ArrowLeft":
                dheading = 0.05;
                break;
            case "ArrowRight":
                dheading = -0.05;
                break;
        }
    });

     $("#webglCanvas").keyup(function (event) {

        var dec = 0.05;
        switch(event.key){
            case "w":
                acceleration[0] = 0.0;
                break;
            case "s":
                acceleration[0] = 0.0;
                break;
            case "a":
                acceleration[1] = 0.0;
                break;
            case "d":
                acceleration[1] = 0.0;
                break;
            case "Shift":
                acceleration[2] = 0.0;
                break;
            case " ":
                acceleration[2] = 0.0;
                break;
            case "ArrowUp":
                dphi = 0.0;
                break;
            case "ArrowDown":
                dphi = 0.0;
                break;
            case "ArrowLeft":
                dheading = 0.0;
                break;
            case "ArrowRight":
                dheading = 0.0;
                break;
        }
     });

    $("#webglCanvas").mousedown(function(event) {
        var rect = canvas[0].getBoundingClientRect();
        mouseDownX = event.clientX - rect.left;
        mouseDownY = event.clientY - rect.top;
        mouseDown = true;
        //console.log(phi);
    });

    $("#webglCanvas").mouseup(function(event) {
        mouseDown = false;
    });

    $("#webglCanvas").mousemove(function(event) {
    //console.log(mouseDown);
        if(mouseDown){

            var rect = canvas[0].getBoundingClientRect();
            var mouseX = event.clientX - rect.left;
            var mouseY = event.clientY - rect.top;

            phi += (-mouseDownY + mouseY)/gl.canvas.height/10.0;
            heading += (-mouseX + mouseDownX)/gl.canvas.width/10.0;
        }
    });

    var canvas = $("#webglCanvas");

    function initWebGL(webglCanvas){
		var gl = webglCanvas[0].getContext("webgl");
    	if( !gl ){
    		throw new Error("Could not get WebGL context!");
    	}
    	return gl;
    }

    // var: gl
    var gl = initWebGL(canvas);

    function makeShader(gl, id, shaderType) {
	    let shade  = $("#" + id);
	    let src    = shade[0].text;
	    let shader = gl.createShader(shaderType);
	    gl.shaderSource(shader, src);
	    gl.compileShader(shader);
	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		let error = gl.getShaderInfoLog(shader);
		gl.deleteShader(shader);
		throw new Error(error);
	    }
	    return shader;
    }

    function makeProgram(vertShade, fragShade){
	    let program = gl.createProgram();
	    gl.attachShader(program, vertShade);
	    gl.attachShader(program, fragShade);

	    gl.linkProgram(program);
	    gl.validateProgram(program);
	    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		var info = gl.getProgramInfoLog(program);
		gl.deleteProgram(program);
		throw new Error(info)
	    }
	    return program;
    }

    function glslProgram(vertID, fragID){
	    let vertShader = makeShader(gl, vertID, gl.VERTEX_SHADER);
 	    let fragShader = makeShader(gl, fragID, gl.FRAGMENT_SHADER);
	    return makeProgram(vertShader, fragShader);
    }


    // Functions to easily set uniforms
    function setIntUniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform1i(uniformAttr, val);
    }

    function setFloatUniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform1f(uniformAttr, val);
    }

    function setVec2Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform2f(uniformAttr, val[0], val[1]);
    }

    function setVec3Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform3f(uniformAttr, val[0], val[1], val[2]);
    }

    function setVec4Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform4f(uniformAttr, val[0], val[1], val[2], val[3]);
    }

    function setMat3Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniformMatrix3fv(uniformAttr, false, val);
    }

    function setMat4Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniformMatrix4fv(uniformAttr, false, val);
    }

    // Functions to create vertex and index buffers
    function setFloat32Buffer(gl, vals) {
        var vertexArray = new Float32Array(vals);
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return vertexBuffer;
    }

    function setUInt16Buffer(gl, vals) {
        var indexArray = new Uint16Array(vals);
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return indexBuffer;
    }

    /* Creates a gl texture using [image]
     */
    function createTexture(gl, image) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    function resize(canvas) {
      var displayWidth  = canvas.clientWidth;
      var displayHeight = canvas.clientHeight;
      if (canvas.width  != displayWidth ||
          canvas.height != displayHeight) {

        canvas.width  = displayWidth;
        canvas.height = displayHeight;
      }
    }

    function createFloatTexture(gl, width, height) {
        var text = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, text);
        gl.texImage2D(
            // Always gl.TEXTURE_2D for a 2D texture.
            gl.TEXTURE_2D,
            // Mipmap level.  Always 0.
            0,
            // Internal format of each pixel.  Here we want an RGBA texture.
            gl.RGBA,
            // Width of the texture.
            width,
            // Height of the texture.
            height,
            // Width of the border of the texture.  Always 0.
            0,
            // The pixel format of the data that is going to be uploaded to the GPU.
            // We have no data here, so use something that matches the internal format.
            gl.RGBA,
            // The type of each component of the pixel that is going to be uploaded.
            // Here we want a floating point texture.
            gl.FLOAT,
            // The data that is going to be uploaded.
            // We don't have any data, so we give null.
            // WebGL will just allocate the texture and leave it blank.
            null
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return text;
    }

    var cameraPos = [];
    var heading = Math.PI/2
    var phi = 120 * Math.PI/180
    var fov = 45 * Math.PI/180.0
    var velocity = [0.0,0.0,0.0]; //w, u and v direction velocities
    var acceleration = [0.0,0.0,0.0]; //for acceleration
    var dheading = 0.0;
    var dphi = 0.0;
    var mouseDown = false;
    var mouseDownX = 0.0;
    var mouseDownY = 0.0;
    //var w;

    function updateCam(){
        var w = vec3.create();
        var u = vec3.create();
        var v = vec3.create();
        var up = vec3.create();

        var cam = vec3.fromValues(cameraPos[0], cameraPos[1], cameraPos[2]);

        vec3.normalize(w, vec3.fromValues(-1*Math.cos(heading)*Math.sin(phi), -1*Math.cos(phi), Math.sin(heading)*Math.sin(phi)));
        vec3.normalize(up, vec3.fromValues(-1*Math.cos(heading)*Math.cos(phi), Math.sin(phi), Math.sin(heading)*Math.cos(phi)));
        vec3.cross(u, up, w);
        vec3.cross(v, w, u);

        var acc = 0.05;

        velocity[0]+=acceleration[0] - acc*2*velocity[0];
        velocity[1]+=acceleration[1] - acc*2*velocity[1];
        velocity[2]+=acceleration[2] - acc*2*velocity[2];

        //if(velocity[0]*velocity[0]<0.1){velocity[0] = 0.0;}
        //if(velocity[1]*acceleration[1]>0.0){acceleration[1] = 0.0; velocity[1] = 0.0;}
        //if(velocity[2]*acceleration[2]>0.0){acceleration[2] = 0.0; velocity[2] = 0.0;}

        if(velocity[0]!=0.0)vec3.add(cam, cam, vec3.scale(w,w,velocity[0]));
        if(velocity[1]!=0.0)vec3.add(cam, cam, vec3.scale(u,u,velocity[1]));
        if(velocity[2]!=0.0)vec3.add(cam, cam, vec3.scale(v,v,velocity[2]));
        if(performance.now()*100.0%5.0==0.0){
            //console.log(w);
            //console.log(heading/Math.PI*180 + ", " + phi/Math.PI*180);
        }
        cameraPos = cam;

        if((phi>0.0&&dphi<0.0) || (phi<Math.PI&&dphi>0.0))phi += dphi;
        heading += dheading;
    }

    var terrain = generateTerrain(75, 2);
    var waterVertices = setFloat32Buffer(gl, [0, 0.5, 0,
                                              74, 0.5, 0,
                                              0, 0.5, -74,
                                              0, 0.5, -74,
                                              74, 0.5, 0,
                                              74, 0.5, -74]
                                              /*[
                                              -1.0, -1.0, 0.0,
                                              1.0, -1.0, 0.0,
                                              -1.0, 1.0, 0.0,
                                              -1.0, 1.0, 0.0,
                                              1.0, -1.0, 0.0,
                                              1.0, 1.0, 0.0
                                              ]*/);



    var width = canvas.width();
    var height = canvas.height();

    var vertexBuffer = setFloat32Buffer(gl, terrain.vertices);
    var indexBuffer = setUInt16Buffer(gl, terrain.indices);
    var textureBuffer = setFloat32Buffer(gl, terrain.texture_coords);
    var biomeBuffer = setFloat32Buffer(gl, terrain.biomes);

    function getBiome(elevation, moisture) {
        var GRASS = 2.0;
        var DIRT = 3.0;
        var DESERT = 1.0;
        var STONE = 4.0;
        var WATER = 0.0;

        if (elevation < .5) {
            return WATER;
        }
        var b = elevation * moisture;
        if (b > 8) {
            return STONE;
        } else if (b > 4) {
            return DIRT;
        } else if (b > .7) {
            return GRASS;
        } else {
            return DESERT;
        }
    }

    function generateTerrain(ndiv, ntex) {
        var w = ndiv;
        var h = ndiv;
        var tstep = ntex/ndiv;
        var p = genP();
        var elevData = [];

        var elev;
        var a = .05;
        var b = 1;
        var c = 2;
        var d;
        var redistrib = 5;
		for (var j = 0; j < h; j++) {
			for (var i = 0; i < w; i++) {
                elev = perlin(3 * i / w, 3 * j / h, p, 20);
				elevData.push(Math.pow(elev, redistrib));
			}
		}

		var minVal = Math.min.apply(null, elevData);
        var maxVal = Math.max.apply(null, elevData);

		var elevation = [];
        var maxElev = 20;

		for (var i = 0; i < elevData.length; i++) {
			elevation.push(maxElev * (elevData[i] - minVal) / (maxVal - minVal));
		}

        var p2 = genP();
        var moistureData = [];
        var moist;
        var redistrib2 = 3;
		for (var j = 0; j < h; j++) {
			for (var i = 0; i < w; i++) {
                moist = perlin(3 * i / w, 3 * j / h, p2, 20);
				moistureData.push(Math.pow(moist, redistrib2));
			}
		}

        var minVal2 = Math.min.apply(null, moistureData);
        var maxVal2 = Math.max.apply(null, moistureData);

		var moisture = [];

		for (var i = 0; i < moistureData.length; i++) {
			moisture.push((moistureData[i] - minVal) / (maxVal - minVal));
		}

        var verts = [];
        var indices = [];
        var tcoords = [];
        var biomes = [];
        var idx = 0;

        for (var j=0; j<h; j++) {
            for (var i=0; i<w; i++) {
                verts.push(i, elevation[j*w +i], -j);
                tcoords.push(i*tstep, -j*tstep);
                biomes.push(getBiome(elevation[j*w + i], moisture[j*w + i]));


/*
                verts.push(
                    i  , elevation[ j   *w + i  ], -j,
                    i+1, elevation[ j   *w + i+1], -j,
                    i  , elevation[(j+1)*w + i  ], -(j+1),
                    i+1, elevation[(j+1)*w + i+1], -(j+1)
                );

                indices.push(
                    idx  , idx+1, idx+2,
                    idx+2, idx+1, idx+3
                );
                idx+=4;

                tcoords.push(
                    i*tstep, -j*tstep,
                    (i+1)*tstep, -j*tstep,
                    i*tstep, -(j+1)*tstep,
                    (i+1)*tstep, -(j+1)*tstep
                );
                biomes.push(
                    getBiome(elevation[ j   *w + i  ], moisture[ j   *w + i  ]),
                    getBiome(elevation[ j   *w + i+1], moisture[ j   *w + i+1]),
                    getBiome(elevation[(j+1)*w + i  ], moisture[(j+1)*w + i  ]),
                    getBiome(elevation[(j+1)*w + i+1], moisture[(j+1)*w + i+1])
                )
*/

            }
        }

        for (var j=0; j<h-1; j++) {
            for (var i=0; i<w-1; i++) {
                var bLeft = (j*h) + i;
                var bRight = (j*h) + i + 1;
                var tLeft = ((j+1)*h) + i;
                var tRight = ((j+1)*h) + i + 1;

                indices.push(
                    bLeft, bRight, tLeft,
                    tLeft, bRight, tRight
                );
            }
        }
        // console.log(verts);
        // console.log(indices);
        cameraPos = [ndiv/2, ndiv/2, 0];
        return {vertices: verts, indices: indices, texture_coords: tcoords, biomes: biomes};
    }

    function getViewMatrix() {
        var e = cameraPos;
        var w = vec3.fromValues(-1*Math.cos(heading), -1*Math.cos(phi), Math.sin(heading))
        vec3.normalize(w,vec3.clone(w));

        var u = vec3.create();
        vec3.cross(u, vec3.fromValues(0.0, 1.0, 0.0), w);
        vec3.normalize(u,vec3.clone(u));

        var v = vec3.create();
        vec3.cross(v, w, u);
        vec3.normalize(v,vec3.clone(v));

        var matA = mat4.fromValues(
            u[0], v[0], w[0], 0.0,
            u[1], v[1], w[1], 0.0,
            u[2], v[2], w[2], 0.0,
            0.0, 0.0, 0.0, 1.0
        );

        var matB = mat4.fromValues(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            -1*e[0], -1*e[1], -1*e[2], 1.0
        );

        var mCam = mat4.create();
        mCam = mat4.multiply(mCam, matA, matB);
        return mCam;
    }

    function getNormalMatrix(viewMatrix) {

    }

    //for testing purposes
    var snowVert = [];
    var snowIndex = [];
    var snowTex = [];

    addSquare(0,0,0,5, snowVert, snowIndex, snowTex);
    addSquare(20,20,-20,5, snowVert, snowIndex, snowTex);
    addSquare(50,15,-50,5, snowVert, snowIndex, snowTex);
    addSquare(100, 15, -60, 5, snowVert, snowIndex, snowTex);
    addSquare(80, 10, -70, 5, snowVert, snowIndex, snowTex);

    var emitter = new Emitter(50,50,-50, 150, 150);

    var snowVertBuffer;
    var snowTexBuffer;
    var snowIndexBuffer;

    function updateParticles(emitter){
    	emitter.update(1);
    	snowVertBuffer = setFloat32Buffer(gl, emitter.vertices);
    	snowTexBuffer = setFloat32Buffer(gl, emitter.texture_coords);
    	snowIndexBuffer = setUInt16Buffer(gl, emitter.indices);
    }

    function startWebGL() {
        // Step 1: Create a LoadQueue object.
        var queue = new createjs.LoadQueue();
        // Step 2: Register the callback function.
        queue.on("complete", function() { runWebGL(queue) }, this);
        // Step 3: List the files you want to load, with their correponding ID.
        queue.loadManifest([
            {
                id: "grass",
                src: "data/grass.jpg"
            }, {
                id: "desert",
                src: "data/desert.jpg"
            }, {
                id: "dirt",
                src: "data/dirt.jpg"
            }, {
                id: "stone",
                src: "data/stone.png"
            }, {
                id: "water",
                src: "data/water.jpg"
            }, {
                id: "waterNormals",
                src: "data/waterNormals.png"
            }, {
                id: "waterDUDV",
                src: "data/waterDUDV.png"
            }, {
            	id: "snow",
            	src: "data/snow.png"
            }
        ]);
    }

    function runWebGL(queue) {
    var gl = initWebGL(canvas);
    gl.getExtension("OES_texture_float");
    gl.getExtension("OES_texture_float_linear");

    resize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    console.log(gl.canvas.width + " " +gl.canvas.height)
    var refractionTexture = createFloatTexture(gl, gl.canvas.width, gl.canvas.height);
    var refractionFBO = gl.createFramebuffer();

    var programTRN = glslProgram("vertexShaderTRN", "fragmentTRN");
    var waterProgram = glslProgram("waterVertex", "waterFragment");
    var programSNOW = glslProgram("vertexSNOW", "fragmentSNOW");

    programTRN["texture0"] = gl.getUniformLocation(programTRN, "grass");
    programTRN["texture1"] = gl.getUniformLocation(programTRN, "dirt");
    programTRN["texture2"] = gl.getUniformLocation(programTRN, "desert");
    programTRN["texture3"] = gl.getUniformLocation(programTRN, "stone");
    programTRN["texture4"] = gl.getUniformLocation(programTRN, "water");

    waterProgram["texture0"] = gl.getUniformLocation(waterProgram, "refraction");
    waterProgram["texture1"] = gl.getUniformLocation(waterProgram, "dudvMap");
    programSNOW["texture5"] = gl.getUniformLocation(programSNOW, "snow");

    var grassTexture = createTexture(gl, queue.getResult("grass", false));
    var desertTexture = createTexture(gl, queue.getResult("desert", false));
    var dirtTexture = createTexture(gl, queue.getResult("dirt", false));
    var stoneTexture = createTexture(gl, queue.getResult("stone", false));
    var waterTexture = createTexture(gl, queue.getResult("water", false));

    var waterDuDvMap = createTexture(gl, queue.getResult("waterDUDV", false));
    var snowTexture = createTexture(gl, queue.getResult("snow", false));

    var start=new Date().getTime() / 1000;

        function drawTerrain(mCam, projMat) {

            setMat4Uniform(gl, programTRN, "mProj", projMat);
            setMat4Uniform(gl, programTRN, "mCam", mCam);
            setFloatUniform(gl, programTRN, "time", 200 / 10);

            if (programTRN.texture0 != null) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, grassTexture);
                gl.uniform1i(programTRN.texture0, 0);
            }
            if (programTRN.texture1 != null) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, dirtTexture);
                gl.uniform1i(programTRN.texture1, 1);
            }
            if (programTRN.texture2 != null) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, desertTexture);
                gl.uniform1i(programTRN.texture2, 2);
            }
            if (programTRN.texture3 != null) {
                gl.activeTexture(gl.TEXTURE3);
                gl.bindTexture(gl.TEXTURE_2D, stoneTexture);
                gl.uniform1i(programTRN.texture3, 3);
            }
            if (programTRN.texture4 != null) {
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, waterTexture);
                gl.uniform1i(programTRN.texture4, 4);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            var positionLocation = gl.getAttribLocation(programTRN, "position")
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3*4, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
            var vTL = gl.getAttribLocation(programTRN, "texture_coords");
            gl.enableVertexAttribArray(vTL);
            gl.vertexAttribPointer(vTL, 2, gl.FLOAT, false, 2*4, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ARRAY_BUFFER, biomeBuffer);
            var biomeLocation = gl.getAttribLocation(programTRN, "a_biome");
            gl.enableVertexAttribArray(biomeLocation);
            gl.vertexAttribPointer(biomeLocation, 1, gl.FLOAT, false, 4, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, terrain.indices.length, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        }

        //SETTING ATTRIBUTES, DRAWING
        //gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        //var positionLocation = gl.getAttribLocation(programTRN, "position")
/*=======

        //Main loop -->
        function updateWebGL() {

            resize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        	gl.clearColor(0.7, 0.7, 0.7, 1.0);
        	gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        	gl.enable(gl.BLEND);

            var projMat = mat4.create();
            mat4.perspective(projMat, fov, width/height, 0.1, 150.0);

            //update cameraPos
            updateCam();
        	updateParticles(emitter);

	        gl.useProgram(programTRN);

	        //SETTING UNIFORMS
	        setVec3Uniform(gl, programTRN, "cameraPos", cameraPos);
	        setFloatUniform(gl, programTRN, "heading", heading);
	        setFloatUniform(gl, programTRN, "phi", phi);
	        setMat4Uniform(gl, programTRN, "mProj", projMat);

	        // setIntUniform(gl, programTRN, "biomes", biomes);

	        if (programTRN.texture0 != null) {
	            gl.activeTexture(gl.TEXTURE0);
	            gl.bindTexture(gl.TEXTURE_2D, grassTexture);
	            gl.uniform1i(programTRN.texture0, 0);
	        }
	        if (programTRN.texture1 != null) {
	            gl.activeTexture(gl.TEXTURE1);
	            gl.bindTexture(gl.TEXTURE_2D, dirtTexture);
	            gl.uniform1i(programTRN.texture1, 1);
	        }
	        if (programTRN.texture2 != null) {
	            gl.activeTexture(gl.TEXTURE2);
	            gl.bindTexture(gl.TEXTURE_2D, desertTexture);
	            gl.uniform1i(programTRN.texture2, 2);
	        }
	        if (programTRN.texture3 != null) {
	            gl.activeTexture(gl.TEXTURE3);
	            gl.bindTexture(gl.TEXTURE_2D, stoneTexture);
	            gl.uniform1i(programTRN.texture3, 3);
	        }
	        if (programTRN.texture4 != null) {
	            gl.activeTexture(gl.TEXTURE4);
	            gl.bindTexture(gl.TEXTURE_2D, waterTexture);
	            gl.uniform1i(programTRN.texture4, 4);
	        }

	        //SETTING ATTRIBUTES, DRAWING
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	        var positionLocation = gl.getAttribLocation(programTRN, "position")
	        gl.enableVertexAttribArray(positionLocation);
	        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3*4, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, null);

	        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
	        var vTL = gl.getAttribLocation(programTRN, "texture_coords");
	        gl.enableVertexAttribArray(vTL);
	        gl.vertexAttribPointer(vTL, 2, gl.FLOAT, false, 2*4, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, null);

	        gl.bindBuffer(gl.ARRAY_BUFFER, biomeBuffer);
	        var biomeLocation = gl.getAttribLocation(programTRN, "a_biome");
	        gl.enableVertexAttribArray(biomeLocation);
	        gl.vertexAttribPointer(biomeLocation, 1, gl.FLOAT, false, 4, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, null);

	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	        gl.drawElements(gl.TRIANGLES, terrain.indices.length, gl.UNSIGNED_SHORT, 0);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

	        gl.useProgram(null);

            //DRAWING SNOW, TESTING
            gl.useProgram(programSNOW);

            if (programSNOW.texture5 != null) {
	            gl.activeTexture(gl.TEXTURE5);
	            gl.bindTexture(gl.TEXTURE_2D, snowTexture);
	            gl.uniform1i(programSNOW.texture5, 5);
	        }

            //SETTING UNIFORMS
            setVec3Uniform(gl, programSNOW, "cameraPos", cameraPos);
            setFloatUniform(gl, programSNOW, "heading", heading);
            setFloatUniform(gl, programSNOW, "phi", phi);
            setMat4Uniform(gl, programSNOW, "mProj", projMat);

            //SETTING ATTRIBUTES
            gl.bindBuffer(gl.ARRAY_BUFFER, snowVertBuffer);
            var positionLocation = gl.getAttribLocation(programSNOW, "position")
>>>>>>> f95d9e70c73aec2c4f98fc9f1ebad397194866f3*/
/*            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3*4, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ARRAY_BUFFER, snowTexBuffer);
	        var vTL = gl.getAttribLocation(programSNOW, "texture_coords");
	        gl.enableVertexAttribArray(vTL);
	        gl.vertexAttribPointer(vTL, 2, gl.FLOAT, false, 2*4, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, snowIndexBuffer);
            gl.drawElements(gl.TRIANGLES, emitter.indices.length, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }*/

        gl.enable(gl.DEPTH_TEST);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);


        function updateWebGL() {
            var currTime = ((new Date().getTime()) / 1000) - start;

            resize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            var projMat = mat4.create();
            mat4.perspective(projMat, fov, gl.canvas.width/gl.canvas.height, 0.1, 200.0);

        	gl.clearColor(0.7, 0.7, 0.7, 1.0);
        	gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(programTRN);

            //update cameraPos
            updateCam();
            var mCam = getViewMatrix();

            updateParticles(emitter);



            gl.bindFramebuffer(gl.FRAMEBUFFER, refractionFBO);
            // Step 2: Attach the texture to the FBO.
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, refractionTexture, 0
            );

            {
                gl.clearColor(0.7, 0.7, 0.7, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                drawTerrain(mCam, projMat);
                gl.flush();
            }

            gl.framebufferTexture2D(
                gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0
            );
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            drawTerrain(mCam, projMat);

            gl.useProgram(waterProgram);

            setMat4Uniform(gl, waterProgram, "mProj", projMat);
            setMat4Uniform(gl, waterProgram, "mCam", mCam);
            setFloatUniform(gl, waterProgram, "time", currTime / 10);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, refractionTexture);
            gl.uniform1i(waterProgram.texture0, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, waterDuDvMap);
            gl.uniform1i(waterProgram.texture1, 1);

            gl.bindBuffer(gl.ARRAY_BUFFER, waterVertices);
            var posLoc = gl.getAttribLocation(waterProgram, "position")
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 3*4, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.useProgram(null);

            //DRAWING SNOW, TESTING
            gl.useProgram(programSNOW);

            if (programSNOW.texture5 != null) {
                gl.activeTexture(gl.TEXTURE5);
                gl.bindTexture(gl.TEXTURE_2D, snowTexture);
                gl.uniform1i(programSNOW.texture5, 5);
            }

            //SETTING UNIFORMS
            setVec3Uniform(gl, programSNOW, "cameraPos", cameraPos);
            setFloatUniform(gl, programSNOW, "heading", heading);
            setFloatUniform(gl, programSNOW, "phi", phi);
            setMat4Uniform(gl, programSNOW, "mProj", projMat);

            //SETTING ATTRIBUTES
            gl.bindBuffer(gl.ARRAY_BUFFER, snowVertBuffer);
            var positionLocation = gl.getAttribLocation(programSNOW, "position")
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3*4, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ARRAY_BUFFER, snowTexBuffer);
            var vTL = gl.getAttribLocation(programSNOW, "texture_coords");
            gl.enableVertexAttribArray(vTL);
            gl.vertexAttribPointer(vTL, 2, gl.FLOAT, false, 2*4, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, snowIndexBuffer);
            gl.drawElements(gl.TRIANGLES, emitter.indices.length, gl.UNSIGNED_SHORT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            gl.useProgram(null);


        	window.requestAnimationFrame(updateWebGL);
        }
        window.requestAnimationFrame(updateWebGL);
    }

    startWebGL();

</script>

</body>
</html>
