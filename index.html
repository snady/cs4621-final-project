<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621: FINAL</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="container">

    <div align="center">
        <canvas id="webglCanvas" style="position: absolute;left: 0; top: 0;border: none; background-color: black; width: 100vw;height: 100vh;" ></canvas>
    </div>

    <br>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="js/gl-matrix-min.js"></script>
<script src="scenes.js"></script>




<!-- Shaders -->


<!-- vertex shader -->
<script id="vertexShaderTRN" type="x-shader/x-vertex">

    attribute vec3 position;
    attribute vec2 texture_coords;

    uniform vec3 cameraPos;
    uniform float heading;
    uniform float phi;
    uniform mat4 mProj;

   //varying vec2 tcoords;

    void main() {
        vec3 e = cameraPos;
        vec3 w = normalize(vec3(cos(heading), cos(phi), -sin(heading)) * -1.0);
        //vec3 w = vec3(0.0, 0.0, 1.0);
        vec3 u = cross(vec3(0.0, 1.0, 0.0), w);
        vec3 v = cross(w, u);

        mat4 A = mat4(
                u.x, v.x, w.x, 0.0,
                u.y, v.y, w.y, 0.0,
                u.z, v.z, w.z, 0.0,
                0.0, 0.0, 0.0, 1.0);
        mat4 B = mat4(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            -e.x, -e.y, -e.z, 1.0);
        mat4 mCam = A*B;

       // tcoords = texture_coords;
       gl_Position = mProj*mCam*vec4(position, 1.0);

    }

</script>

<script id="fragmentTRN" type="x-shader/x-fragment">
    precision highp float;

    // Main
    void main() {
        gl_FragColor = vec4(0, 1.0, 0, 1.0);
    }

</script>


<script>

    var canvas = $("#webglCanvas");

    function initWebGL(webglCanvas){
		var gl = webglCanvas[0].getContext("webgl");
    	if( !gl ){
    		throw new Error("Could not get WebGL context!");
    	}
    	return gl;
    }

    // var: gl
    var gl = initWebGL(canvas);

    function makeShader(gl, id, shaderType) {
	    let shade  = $("#" + id);
	    let src    = shade[0].text;
	    let shader = gl.createShader(shaderType);
	    gl.shaderSource(shader, src);
	    gl.compileShader(shader);
	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		let error = gl.getShaderInfoLog(shader);
		gl.deleteShader(shader);
		throw new Error(error);
	    }
	    return shader;
    }

    function makeProgram(vertShade, fragShade){
	    let program = gl.createProgram();
	    gl.attachShader(program, vertShade);
	    gl.attachShader(program, fragShade);

	    gl.linkProgram(program);
	    gl.validateProgram(program);
	    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		var info = gl.getProgramInfoLog(program);
		gl.deleteProgram(program);
		throw new Error(info)
	    }
	    return program;
    }

    function glslProgram(vertID, fragID){
	    let vertShader = makeShader(gl, vertID, gl.VERTEX_SHADER);
 	    let fragShader = makeShader(gl, fragID, gl.FRAGMENT_SHADER);
	    return makeProgram(vertShader, fragShader);
    }


    // Functions to easily set uniforms
    function setIntUniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform1i(uniformAttr, val);
    }

    function setFloatUniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform1f(uniformAttr, val);
    }

    function setVec2Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform2f(uniformAttr, val[0], val[1]);
    }

    function setVec3Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform3f(uniformAttr, val[0], val[1], val[2]);
    }

    function setVec4Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniform4f(uniformAttr, val[0], val[1], val[2], val[3]);
    }

    function setMat3Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniformMatrix3fv(uniformAttr, false, val);
    }

    function setMat4Uniform(gl, program, uniform, val) {
        var uniformAttr = gl.getUniformLocation(program, uniform);
        gl.uniformMatrix4fv(uniformAttr, false, val);
    }

    // Functions to create vertex and index buffers
    function setFloat32Buffer(gl, vals) {
        var vertexArray = new Float32Array(vals);
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return vertexBuffer;
    }

    function setUInt16Buffer(gl, vals) {
        var indexArray = new Uint16Array(vals);
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return indexBuffer;
    }

    /* Creates a gl texture using [image]
     */
    function createTexture(gl, image) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    function resize(canvas) {
  // Lookup the size the browser is displaying the canvas.
      var displayWidth  = canvas.clientWidth;
      var displayHeight = canvas.clientHeight;
      // Check if the canvas is not the same size.
      if (canvas.width  != displayWidth ||
          canvas.height != displayHeight) {

        // Make the canvas the same size
        canvas.width  = displayWidth;
        canvas.height = displayHeight;
      }
    }

    var terrain = generateTerrain();

    // var terraVertices =
    // [0, 0, 0,
    // 10, 0, 0,
    // 10, 0, -10,
    // 10, 0, -10,
    // 0, 0, -10,
    // 0, 0, 0];

    // var terraFaces =
    // [0, 1, 2,
    // 3, 4, 5];

    var cameraPos = [50, 30, 15];
    var heading = Math.PI/2
    var phi = 120 * Math.PI/180
    var fov = 45 * Math.PI/180.0

    var width = canvas.width();
    var height = canvas.height();

    var programTRN = glslProgram("vertexShaderTRN", "fragmentTRN");

    var vertexBufferT = setFloat32Buffer(gl, terrain.vertices);
    var indexBufferF = setUInt16Buffer(gl, terrain.indices);

    // Random terrain generation functions
    function genP() {
        var p = [];

        for (var i=0; i<256; i++) {
            p.push(i);
        }

        for (var j=255; j>=0; j--) {
            var val = Math.floor(Math.random()*j + 1);
            var temp = p[j];
            p[j] = p[val];
            p[val] = temp
        }

        return p;
    }

    function noise(x, y, p) {
        var xi = Math.floor(x & 255);
        var yi = Math.floor(y & 255);

        var xf = x - Math.floor(x);
        var yf = y - Math.floor(y);

        var u = fade(xf);
        var v = fade(yf);

        var a = p[p[ xi]    +  yi];
        var b = p[p[ xi]    + (yi+1)];
        var c = p[p[(xi+1)] +  yi];
        var d = p[p[(xi+1)] + (yi+1)];

        var x1 = lerp(grad(a, xf, yf),     grad(c, xf - 1, yf    ), u);
        var x2 = lerp(grad(b, xf, yf - 1), grad(d, xf - 1, yf - 1), u);

        return (lerp(x1, x2, v) + 1) / 2;
    }

    function grad(hash, x, y) {
        switch (hash & 0xF) {
            case 0x0:
                return x + y;
            case 0x1:
                return -x + y;
            case 0x2:
                return x - y;
            case 0x3:
                return -x - y;
            case 0x4:
                return y + x;
            case 0x5:
                return -y + x;
            case 0x6:
                return y - x;
            case 0x7:
                return -y - x;
            case 0x8:
                return x + y;
            case 0x9:
                return -x + y;
            case 0xA:
                return x - y;
            case 0xB:
                return -x - y;
            case 0xC:
                return y + x;
            case 0xD:
                return -y + x;
            case 0xE:
                return y - x;
            case 0xF:
                return -y - x;
            default:
                return 0; // never happens
        }
    }

    function fade(t) {
        return 6 * Math.pow(t, 5) - 15 * Math.pow(t, 4) + 10 * Math.pow(t, 3);  // 6t^5 - 15t^4 + 10t^3
    }

    function lerp(a, b, x) {
        return a + x * (b - a);
    }

    function perlin(x, y, p, nOctaves) {
        var total = 0;
        var frequency = 1;
        var amplitude = 1;
        var maxVal = 0;
        var persistence = .4;

        for(var i=0; i<nOctaves; i++) {
            total += noise(x * frequency, y * frequency, p) * amplitude;

            maxVal += amplitude;

            amplitude *= persistence;
            frequency *= 2;
        }

        return total/maxVal;
    }

    function generateTerrain() {
        var w = 100;
        var h = 100;

        var p = genP();
        var noiseData = [];

        var elev;
        var a = .05;
        var b = 1;
        var c = 2;
        var d;
		for (var j = 0; j < h; j++) {
			for (var i = 0; i < w; i++) {
                elev = Math.sqrt(perlin(3 * i / w, 3 * j / h, p, 20) * 10);
                // d = Math.sqrt(Math.pow(Math.abs(i/w-.5), 2) + Math.pow(Math.abs(j/h-.5), 2))*2;
                // elev += a - b * Math.pow(d,c);
                // console.log(d);
				noiseData.push(elev);
			}
		}

		var minVal = Math.min.apply(null, noiseData)
        var maxVal = Math.max.apply(null, noiseData);

		var elevData = [];
        var maxElev = 20;


		for (var i = 0; i < noiseData.length; i++) {
			elevData.push(maxElev * (noiseData[i] - minVal) / (maxVal - minVal));
		}

        var verts = [];
        var indices = [];
        var idx = 0;
        for (var j=0; j<h-1; j++) {
            for (var i=0; i<w-1; i++) {
                verts.push(
                    i  , elevData[ j   *w + i  ], -j,
                    i+1, elevData[ j   *w + i+1], -j,
                    i  , elevData[(j+1)*w + i  ], -(j+1),
                    i+1, elevData[(j+1)*w + i+1], -(j+1)
                )

                indices.push(
                    idx  , idx+1, idx+2,
                    idx+2, idx+1, idx+3
                )
                idx+=4;
            }
        }
        // console.log(verts);
        // console.log(indices);
        return {vertices: verts, indices: indices};
    }

    //Main loop -->
    function updateWebGL() {

        resize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    	gl.clearColor(0.7, 0.7, 0.7, 1.0);
    	gl.clear(gl.COLOR_BUFFER_BIT);

        gl.enable(gl.DEPTH_TEST);

        var projMat = mat4.create();
        mat4.perspective(projMat, fov, width/height, 0.1, 100.0);

        gl.useProgram(programTRN);
        //SETTING UNIFORMS
        setVec3Uniform(gl, programTRN, "cameraPos", cameraPos);

        setFloatUniform(gl, programTRN, "heading", heading);

        setFloatUniform(gl, programTRN, "phi", phi);

        setMat4Uniform(gl, programTRN, "mProj", projMat);

        //SETTING ATTRIBUTES, DRAWING
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferT);
        var positionLocation = gl.getAttribLocation(programTRN, "position")
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3*4, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferF);
        gl.drawElements(gl.TRIANGLES, terrain.indices.length, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        gl.useProgram(null);

    	window.requestAnimationFrame(updateWebGL);
    }

    window.requestAnimationFrame(updateWebGL);
</script>

</body>
</html>
